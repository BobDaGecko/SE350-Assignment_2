// @formatter:off
////////////////////////////////////////////////////////////////////////////
//                         Kellen Siczka - 2082880                        //
//                        DePaul University - 24/25                       //
//              SE350 - Object-Oriented Software Development              //
//                ksiczka@depaul.edu | edu@kellensiczka.com               //
//         Eclipse Adoptium JRE 21.0.5.11 - Win11/WSL2 - MS VSCode        //
//           Completed by Kellen Siczka unless otherwise noted            //
//        Note: Docstrings and explanations may be generated by AI        //
////////////////////////////////////////////////////////////////////////////
//                         Week 7 - Spring Quarter                        //
//                          Lab 8 - Due 05-12-2025                        //
//      File Info: #3/3 | DungeonStructureTest.java | JUnit Test Case     //
////////////////////////////////////////////////////////////////////////////
// @formatter:on

package dpu.se350.assignment2;

import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import java.util.List;

/**
 * Unit tests for the Dungeon, Chamber, and Door classes.
 */
public class DungeonStructureTest {
    private Chamber startChamber;
    private Chamber chamberWithItem;
    private Chamber chamberWithGuardedDoor;
    private Chamber goalChamber;
    private Door unguardedDoor;
    private Door guardedDoor;
    private Monster monster;
    private Character player;
    private Item item;
    private Dungeon dungeon;

    @Before
    public void setup() {
        // Setup chambers
        startChamber = new Chamber();
        item = new Axe();
        chamberWithItem = new Chamber(item);
        chamberWithGuardedDoor = new Chamber();
        goalChamber = new Chamber();

        // Setup player
        player = new Warrior("Aragorn");

        // Setup monster
        monster = new Monster("Goblin", 2, 0, 5);

        // Setup doors
        unguardedDoor = Door.connect(startChamber, chamberWithItem);
        guardedDoor = Door.connect(chamberWithItem, chamberWithGuardedDoor, monster);
        Door.connect(chamberWithGuardedDoor, goalChamber);

        // Setup dungeon
        dungeon = new Dungeon(player, startChamber, goalChamber);
    }

    @Test
    public void testChamberCreation() {
        // Test empty chamber
        assertEquals(0, new Chamber().getItems().size());

        // Test chamber with item
        assertEquals(1, chamberWithItem.getItems().size());
        assertTrue(chamberWithItem.getItems().contains(item));
    }

    @Test
    public void testDoorConnections() {
        // Start chamber should have one door
        assertEquals(1, startChamber.getDoors().size());

        // Chamber with item should have two doors
        assertEquals(2, chamberWithItem.getDoors().size());

        // Test door connections
        assertTrue(startChamber.getDoors().contains(unguardedDoor));
        assertTrue(chamberWithItem.getDoors().contains(unguardedDoor));
        assertTrue(chamberWithItem.getDoors().contains(guardedDoor));
        assertTrue(chamberWithGuardedDoor.getDoors().contains(guardedDoor));
    }

    @Test
    public void testDoorPassability() {
        // Unguarded door should be passable
        assertTrue(unguardedDoor.canPass());

        // Guarded door should not be passable
        assertFalse(guardedDoor.canPass());

        // Defeat the monster
        monster.takeDamage(5);

        // Now the door should be passable
        assertTrue(guardedDoor.canPass());
    }

    @Test
    public void testDungeonNavigation() {
        // Start at startChamber
        assertEquals(startChamber, dungeon.getCurrentChamber());
        assertFalse(dungeon.isFinished());

        // Move to chamberWithItem
        dungeon.setCurrentChamber(chamberWithItem);
        assertEquals(chamberWithItem, dungeon.getCurrentChamber());
        assertFalse(dungeon.isFinished());

        // Move to chamberWithGuardedDoor
        dungeon.setCurrentChamber(chamberWithGuardedDoor);
        assertEquals(chamberWithGuardedDoor, dungeon.getCurrentChamber());
        assertFalse(dungeon.isFinished());

        // Move to goalChamber
        dungeon.setCurrentChamber(goalChamber);
        assertEquals(goalChamber, dungeon.getCurrentChamber());
        assertTrue(dungeon.isFinished());
    }

    @Test
    public void testAvailableActions() {
        // Actions in start chamber: only move
        List<Action> startActions = dungeon.getActions();
        assertEquals(1, startActions.size());
        assertTrue(startActions.get(0) instanceof Move);

        // Move to chamber with item
        dungeon.setCurrentChamber(chamberWithItem);

        // Actions in chamber with item: pick item, fight monster, move to unguarded chamber
        List<Action> itemChamberActions = dungeon.getActions();
        assertEquals(3, itemChamberActions.size());  // Updated to expect 3 actions: pick, fight, move
        boolean hasPick = false;
        boolean hasFight = false;
        boolean hasMove = false;

        for (Action action : itemChamberActions) {
            if (action instanceof Pick)
                hasPick = true;
            if (action instanceof Fight)
                hasFight = true;
            if (action instanceof Move)
                hasMove = true;
        }

        assertTrue(hasPick);
        assertTrue(hasFight);
        assertTrue(hasMove); // We should have a move action for the unguarded door

        // Defeat monster
        monster.takeDamage(5);

        // Now we should have move actions
        List<Action> updatedActions = dungeon.getActions();
        assertTrue(updatedActions.size() > 0);

        hasMove = false;
        for (Action action : updatedActions) {
            if (action instanceof Move) {
                hasMove = true;
                break;
            }
        }
        assertTrue(hasMove);
    }

    @Test
    public void testGameFinished() {
        // Game not finished initially
        assertFalse(dungeon.isFinished());

        // Game finished when player reaches goal
        dungeon.setCurrentChamber(goalChamber);
        assertTrue(dungeon.isFinished());

        // Reset and test player death
        dungeon = new Dungeon(player, startChamber, goalChamber);
        assertFalse(dungeon.isFinished());

        // Kill player
        player.takeDamage(20);
        assertTrue(player.isDefeated());

        // Game should be finished when player is dead
        assertTrue(dungeon.isFinished());
    }
}
