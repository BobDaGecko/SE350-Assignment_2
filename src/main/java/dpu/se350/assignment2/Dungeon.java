// @formatter:off
////////////////////////////////////////////////////////////////////////////
//                         Kellen Siczka - 2082880                        //
//                        DePaul University - 24/25                       //
//              SE350 - Object-Oriented Software Development              //
//                ksiczka@depaul.edu | edu@kellensiczka.com               //
//         Eclipse Adoptium JRE 21.0.5.11 - Win11/WSL2 - MS VSCode        //
//           Completed by Kellen Siczka unless otherwise noted            //
//        Note: Docstrings and explanations may be generated by AI        //
////////////////////////////////////////////////////////////////////////////
//                         Week 7 - Spring Quarter                        //
//                          Lab 8 - Due 05-12-2025                        //
//             File Info: #17/17 | Dungeon.java | Java Class              //
////////////////////////////////////////////////////////////////////////////
// @formatter:on

package dpu.se350.assignment2;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents the dungeon game world, containing chambers, a player character, and tracking game
 * state.
 */
public class Dungeon {
    private Character player;
    private Chamber currentChamber;
    private Chamber goalChamber;
    private boolean isFinished;

    /**
     * Creates a new dungeon with the specified player, starting chamber, and goal chamber.
     *
     * @param player The player character
     * @param startChamber The chamber where the player starts
     * @param goalChamber The chamber the player needs to reach to win
     */
    public Dungeon(Character player, Chamber startChamber, Chamber goalChamber) {
        this.player = player;
        this.currentChamber = startChamber;
        this.goalChamber = goalChamber;
        this.isFinished = false;
    }

    /**
     * Gets the player character.
     *
     * @return The player character
     */
    public Character getPlayer() {
        return player;
    }

    /**
     * Gets the current chamber the player is in.
     *
     * @return The current chamber
     */
    public Chamber getCurrentChamber() {
        return currentChamber;
    }

    /**
     * Sets the current chamber the player is in. If the player reaches the goal chamber, the game
     * is finished.
     *
     * @param chamber The new current chamber
     */
    public void setCurrentChamber(Chamber chamber) {
        this.currentChamber = chamber;

        // Check win condition
        if (chamber == goalChamber) {
            System.out.println("Congratulations! You've reached the goal chamber!");
            isFinished = true;
        }
    }

    /**
     * Gets whether the game is finished (player won or lost).
     *
     * @return true if the game is finished, false otherwise
     */
    public boolean isFinished() {
        return isFinished || player.isDefeated();
    }

    /**
     * Sets whether the game is finished.
     *
     * @param finished The new finished state
     */
    public void setFinished(boolean finished) {
        this.isFinished = finished;
    }

    /**
     * Gets the list of possible actions the player can take in the current situation.
     *
     * @return The list of available actions
     */
    public List<Action> getActions() {
        List<Action> actions = new ArrayList<>();

        // Add fight actions for monsters guarding doors
        for (Door door : currentChamber.getDoors()) {
            Monster monster = door.getMonster();
            if (monster != null && !monster.isDefeated()) {
                actions.add(new Fight(this, door, monster));
            }
        }

        // Add pick actions for items in the chamber
        for (Item item : currentChamber.getItems()) {
            actions.add(new Pick(this, item));
        }

        // Add move actions for doors that can be passed
        for (Door door : currentChamber.getDoors()) {
            if (door.canPass()) {
                actions.add(new Move(this, door));
            }
        }

        return actions;
    }
}
